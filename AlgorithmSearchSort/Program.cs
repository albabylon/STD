using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AlgorithmSearchSort
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // Поиск
            // Линейный поиск позволяет проходить по всем элементам массива друг за другом, проверяя их на соответствие искомому элементу, соответственно, его сложность — O(n).
            //
            // Бинарный поиск позволяет сократить количество операций, путем отсечения сразу половины проверяемых значений за 1 итерацию:
            // Для начала, данные подготавливаются — массив сортируется.
            // После этого проверяется серединный элемент массива.В результате этой проверки у алгоритма есть 3 пути:
            // Если проверяемый элемент равен искомому — вернуть индекс.
            // Если проверяемый элемент больше искомого — продолжить поиск на «левой» половине массива, то есть на числах меньше проверяемого.
            // Если проверяемый элемент меньше искомого — продолжить поиск на «правой» половине массива, то есть на числах больше проверяемого.

            // Важно понимать, в чем выгода. Если мы используем статичные данные, которые не меняются или меняются гораздо реже, чем происходит поиск по ним, то нам подойдет бинарный поиск.
            // Потому что выгода в операции поиска будет перекрывать потраченное время на сортировку.
            // Однако, если данные часто меняются(вставки, удаления элементов в массиве), то операция сортировки будет занимать больше времени, чем мы выиграем на поиске.
            int[] array = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
            int result = BinarySearch(7, array, 0, 8);
            Console.WriteLine(result);
            Console.ReadLine();

            // Сортировка
            // Пузырьковая сортировка bublesort O(n2) - Данный алгоритм за один проход по массиву «проносит» наибольший элемент в конец массива и оставляет его там. Количество таких проходов будет равно n.
            // Для того чтобы определить, нужно ли переставлять элемент, производится операция сравнения двух соседних элементов, если левый элемент больше правого, то они меняются местами в массиве.
            int[] arrayToSort = new int[] { 1, 4, 3, 2, 6, 7, 5, 8, 9 };
            BubbleSort(arrayToSort);

            // Быстрая сортировка quicksort O(n log n)
            // Общая идея алгоритма состоит в следующем:
            // 1. Выбрать из массива элемент, называемый опорным.Это может быть любой из элементов массива.От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность
            // 2. Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие».
            // 3. Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.
            // Недостатки:
            // При неудачном выборе опорных элементов скорость алгоритма деградирует до O(n^{2}).
            // Глубина рекурсии может достигать O(n), в результате чего при больших n может произойти переполнение программного стека.

            // Пирамидальная сортировка HeapSort O(n log n)
            // Данный алгоритм имеет доказанную оценку худшего случая — O(n log n) и не деградирует

            // Алгоритм IntroSort совмещает в себе несколько алгоритмов: QuickSort, HeapSort и алгоритм сортировки вставками для самых малых данных.
            // Именно IntroSort используется в методе Sort, который есть у массивов в .Net

            int[] arrayToTask = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        }

        static int BinarySearch(int value, int[] array, int left, int right)
        {
            while (left <= right)
            {
                var middle = (left + right) / 2;

                var midElement = array[middle];

                if (midElement == value)
                {
                    return middle;
                }
                else if (value < midElement)
                {
                    right = middle - 1;
                }
                else
                {
                    left = middle + 1;
                }
            }

            return -1;
        }

        static void BubbleSort(int[] array)
        {
            int temp;
            for (int i = 0; i < array.Length - 1; i++)
            {
                for (int j = i + 1; j < array.Length; j++)
                {
                    if (array[i] > array[j])
                    {
                        temp = array[i];
                        array[i] = array[j];
                        array[j] = temp;
                    }
                }
            }
        }
    }
}
